# FINAL REPORT: SIFT 

```
Anne Zepecki (Manager)
Lama Abdullah Rashed (Tester)
Jose Antonio Ramos (Language Guru)
Rishav Kumar (System Architect)
Suryanarayana Venkata Akella (System Architect)
```

<!-- vscode-markdown-toc -->
 1. [Introduction](#Introduction)
 2. [Language Tutorial](#LanguageTutorial)
 3. [Architectural Design](#ArchitecturalDesign)
 4. [Test Plan](#TestPlan)
 5. [Summary](#Summary)
<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

##  1. <a name='Introduction'></a>Introduction

Sift is a programming language designed to optimize text processing and filtering for natural language processing (NLP) applications.
Sift draws inspiration from the elegance of C’s syntax while adding its own unique flair. This imperative language is designed for users with some programming experience as knowledge of C or a similar language will allow users to instantly recognize and understand the basic structure of Sift. However, it is the text-specific processing tools that make Sift stand out as the best language to use for NLP purposes; piping, filtering, and basic tokenization functionality give users the tools they need to seamlessly integrate Sift into their existing or future NLP workflows.

##  2. <a name='LanguageTutorial'></a>Language Tutorial

Sift files are signified with the `.sf` suffix.

### Fundamentals 

**Data Types** 

Sift consists of several key primitive data types: `int`, `float`, `char`, `str`, `sym` and `bool`. Sift also includes an `arr` non-primitive data type that holds an array of non-primitive type `t` in `arr<t>`. 

__For strings, we also implemented additional string operations since Sift is a language meant for text-processing__. 

Example usage with `str_add`: 

```js
str a = "ap";
str b = "ple";
str c = str_add(a, b);
c |> <out>;
```

**Identifiers** 

Variable declaration follows the following syntax: 

```js
int a = 3;
```

**Operators: Arithmetic**

The following arithmetic operators are available: `+`, `-`, `/`, `*`, and `%`. These operators function in the same way as they would in C. 

**Operators: Relational**

The following relational operators are available: `>`, `<`, `==`, `!=`, `<=`, `>=`. These operators function in the same way as they would in C. 

**Operators: Logical**

The following logical operators are available: `&&`, `||`, `!`. These operators function in the same way as they would in C. 

**Control Flow**

The following functionality for control flow is available: 
`if/else` blocks, `while` loops, `for` loops, `continue` keyword, `return` keyword, `break` keyword. 

**Function Calls**

In Sift, functions are declared with the keyword `def`. The function should have a name and a consequent block of code to be executed when the function is called.
A function can take zero, one or more arguments and return an expression of a certain type; the retuned type should be declared in the function header. 

**Syntax:**
```js
def list<(sym,int)> 
    get_frequencies(list<sym> tokens) {
    return ... ; 
}
```
```js
def hello() {
    print(“Hello World!”);
}
```

### Sift-Specific Functionality
 
**Pipe Operators**

There is also a pipe operator `|>` much like pipe in ocaml which applies a function to another.

#### Example Syntax

```js
str x = "hellopeople";
str s = f |> g |> x;
```

**Lambdas**

The `lambda` keyword is used to denote an anonymous function. 

```js 
lambda x : x + 1;
```

**Regular Expressions** 

We have implemented built-in regex functionality as a part of Sift. 

See example usage of `match`: 

```js
arr<str> numbers = match("The wiiiiiiiiiild wild cat lived in a mild climate.", "(w|m)i*ld");
```

**NLP Features** 

We have implemented built-in NLP Features as a part of Sift.

See example usage of `word_tokenize`:

```js
str big_line = "Lorem ipsum dolor sit amet";
arr<str> tokenized_version = word_tokenize(big_line);
for(int i=0; i < 10; i++) {
    tokenized_version[i] |> <out>;
}
```

##  3. <a name='ArchitecturalDesign'></a>Architectural Design 

### SCANNER

_Relevant files_: `scanner.mll`

The scanner file takes a Sift source program and translates the stream of characters into a stream of tokens for identifiers, keywords, operators, literals, etc. At this stage, any whitespace and comments are discarded from the stream of tokens.
The scanner is implemented in Ocamllex, and uses regular expressions for scanning string literals, identifiers, digits and other language constructs. If a token is not identified by the scanner, it will throw an error. The tokens processed by the scanner are passed to the parser for the next step in the pipeline.

### PARSER AND AST

_Relevant files_: `parser.mly` and `ast.ml`

The parser accepts the tokens generated by the scanner and creates an abstract syntax tree (AST) with the grammar provided in `parser.mly`. The parser enforces a Context Free Grammar (CFG) consisting of productions and their precedence. The parser also defines the entry point of the program. The parser is written in Ocamlyacc. If the syntax of the program is incorrect, then the parser throws a `Stdlib.parse_error`.

The AST defines the token syntax tree and includes binary and unary operators, primitive data types, expression, and constructs of the language.

### SEMANTICS

_Relevant files_: `sast.ml` and `semantics.ml`

The semantic checker converts the AST into a semantically checked syntax tree (SAST). The semantic analysis process performs validation like ensuring that variables are declared and have been declared with valid values. It  maintains the scope of the variables and functions using a symbol table (as Sift is a statically type language). The SAST also validates whether the built-in C functions were provided the correct types or not. Once the semantic checks are completed, an SAST is generated and passed as an input to the IR Generator.

### IR GENERATION

The IR generator takes an SAST and outputs LLVM code. We use ocaml llvm's library to map expression to LLVM accepted data types. 

### BUILT-IN LIBRARIES

Includes string operations, NLP features, and regular expressions.

##  4. <a name='TestPlan'></a>Test Plan

### Source Programs 

**While Loop** 

See an example program that tests while loop (`test-while1.sf`)

```js
def int while_test(int a){
      while ( a < 4 ) {
        a = a + 1; 
        print(a); 
    }
    return 0;
}

def int main(){
    while_test(2);
    return 0;
}
```

**Functions** 

See an example program that tests functions (`test-function1.sf`)

```js
def int func(int x, int y){
     return x+y;
}

def int main(){
    print(func(3,4));
    return 0;
}
```

**Pipe Operator**

See an example program that tests the pipe operator (`test-pipe1.sf`)

```js
def int func(int a, int b, int c, int d) {
    return a + b + c + d;
}

def int main() {
   print((2 |> func(6, 4, 9)));
   return 0;
}
```

### Automation

In our `Makefile`, we have a target `make test` that runs an entire test suite that consists of tests for all of the major features of Sift. We compare the output of running each test with the expected `.out` file for that particular test to determine whether the test has passed or failed. 

##  5. <a name='Summary'></a>Summary

### Breakdown of Work

**Project Proposal** 

_Implemented by_: Anne, José, Rishav, Surya, Lama

**Language Reference Manual**

_Implemented by_: Anne, José, Surya, Rishav, Lama

**Scanner**

_Implemented by_: Rishav, José, Lama, Anne, Surya 

**Parser and AST**

_Implemented by_: José, Lama, Rishav, Anne, Surya 

**Semantics**

_Implemented by_: José and Lama

**IR Generation**

_Implemented by_: José, Lama, and Rishav

**Built-In Libraries**

_Implemented by_: Rishav and Surya

**Tests**

_Implemented by_: Rishav, Lama, Anne, Surya, José

**Final Report**

_Implemented by_: Anne, Rishav

### Takeaways 

**Anne**

My most important takeaway from the project was probably in gaining the understanding of how all the pieces of compiling a language come together. I thought that I understood well from the lectures, but I think it was a different experience actually working on the implementation and having to understand all the different minor details of a language and the way that it's implemented can make a really big difference. I think that it really stressed the importance of design more generally, but also specifically in the case of programming languages. I definitely gained more of an appreciation for the coding languages I use in my day-to-day life and the beauty of how they were implemented. 

**Lama**

**Jose**

**Rishav**

**Surya** 


### Advice

The biggest piece of advice would be to try to implement each stage as soon as the relevant lecture is covered. We definitely found it useful to have for the most part completed the scanner/parser by the Hello World milestone. Working on things in stages makes it so that the work can build on top of each stage. 
