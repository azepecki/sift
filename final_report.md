# FINAL REPORT: SIFT 

```
Anne Zepecki (Manager)
Lama Abdullah Rashed (Tester)
Jose Antonio Ramos (Language Guru)
Rishav Kumar (System Architect)
Suryanarayana Venkata Akella (System Architect)
```

<!-- vscode-markdown-toc -->
 1. [Introduction](#Introduction)
 2. [Language Tutorial](#LanguageTutorial)
 3. [Architectural Design](#ArchitecturalDesign)
 4. [Test Plan](#TestPlan)
 5. [Summary](#Summary)
<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

##  1. <a name='Introduction'></a>Introduction

Sift is a programming language designed to optimize text processing and filtering for natural language processing (NLP) applications.
Sift draws inspiration from the elegance of C’s syntax while adding its own unique flair. This imperative language is designed for users with some programming experience as knowledge of C or a similar language will allow users to instantly recognize and understand the basic structure of Sift. However, it is the text-specific processing tools that make Sift stand out as the best language to use for NLP purposes; piping, filtering, and basic tokenization functionality give users the tools they need to seamlessly integrate Sift into their existing or future NLP workflows.

##  2. <a name='LanguageTutorial'></a>Language Tutorial

### Fundamentals 

**Data Types** 

Sift consists of several key primitive data types: `int`, `float`, `char`, `str`, `sym` and `bool`. Sift also includes an `arr` non-primitive data type that holds an array of non-primitive type `t` in `arr<t>`. 

**Identifiers** 

Variable declaration follows the following syntax: 

```js
int a = 3;
```

**Operators: Arithmetic**

The following arithmetic operators are available: `+`, `-`, `/`, `*`, and `%`. These operators function in the same way as they would in C. 

**Operators: Relational**

The following relational operators are available: `>`, `<`, `==`, `!=`, `<=`, `>=`. These operators function in the same way as they would in C. 

**Operators: Logical**

The following logical operators are available: `&&`, `||`, `!`. These operators function in the same way as they would in C. 

**Control Flow**

The following functionality for control flow is available: 
`if/else` blocks, `while` loops, `for` loops, `continue` keyword, `return` keyword, `break` keyword. 

**Function Calls**

In Sift, functions are declared with the keyword `def`. The function should have a name and a consequent block of code to be executed when the function is called.
A function can take zero, one or more arguments and return an expression of a certain type; the retuned type should be declared in the function header. 

**Syntax:**
```js
def list<(sym,int)> 
    get_frequencies(list<sym> tokens) {
    return ... ; 
}
```
```js
def hello() {
    print(“Hello World!”);
}
```

### Sift-Specific Functionality
 
**Pipe Operators**

There is also a pipe operator `|>` much like pipe in ocaml which applies a function to another.

#### Example Syntax

```js
str x = "hellopeople";
str s = f |> g |> x;
```

**Lambdas**

The `lambda` keyword is used to denote an anonymous function. 

`lambda x : x + 1;`

**Regular Expressions** 

**NLP Features** 


##  3. <a name='ArchitecturalDesign'></a>Architectural Design 

### SCANNER

_Relevant files_: `scanner.mll`

The scanner file takes a Sift source program and translates the stream of characters into a stream of tokens for identifiers, keywords, operators, literals, etc. At this stage, any whitespace and comments are discarded from the stream of tokens.
The scanner is implemented in Ocamllex, and uses regular expressions for scanning string literals, identifiers, digits and other language constructs. If a token is not identified by the scanner, it will throw an error. The tokens processed by the scanner are passed to the parser for the next step in the pipeline.

_Implemented by_: Rishav, José, Lama, Anne, Surya 

### PARSER AND AST

_Relevant files_: `parser.mly` and `ast.ml`

The parser accepts the tokens generated by the scanner and creates an abstract syntax tree (AST) with the grammar provided in `parser.mly`. The parser enforces a Context Free Grammar (CFG) consisting of productions and their precedence. The parser also defines the entry point of the program. The parser is written in Ocamlyacc. If the syntax of the program is incorrect, then the parser throws a `Stdlib.parse_error`.

The AST defines the token syntax tree and includes binary and unary operators, primitive data types, expression, and constructs of the language.

_Implemented by_: José, Lama, Rishav, Anne, Surya 

### SEMANTICS

_Relevant files_: `sast.ml` and `semantics.ml`

The semantic checker converts the AST into a semantically checked syntax tree (SAST). The semantic analysis process performs validation like ensuring that variables are declared and have been declared with valid values. It  maintains the scope of the variables and functions using a symbol table (as Sift is a statically type language). The SAST also validates whether the built-in C functions were provided the correct types or not. Once the semantic checks are completed, an SAST is generated and passed as an input to the IR Generator.

_Implemented by_: José and Lama

### IR GENERATION

The IR generator takes an SAST and outputs LLVM code. We use ocaml llvm's library to map expression to LLVM accepted data types. 

_Implemented by_: José, Lama, and Rishav

### BUILT-IN LIBRARIES

_Implemented by_: Rishav and Surya

##  4. <a name='TestPlan'></a>Test Plan

### Source Programs 

**Fundamental Functionality** 

**Regex** 

**NLP Features**

### Automation

##  5. <a name='Summary'></a>Summary

### Other Contributions 

**Project Proposal** 

__Implemented by__: Anne, José, Rishav, Surya, Lama

**Language Reference Manual**

__Implemented by__: Anne, José, Surya, Rishav, Lambdas

**Final Report**

__Implemented by__: Anne, Rishav

### Takeaways 

**Anne**

**Lama**

**Jose**

**Rishav**

**Surya** 



