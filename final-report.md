# FINAL REPORT: SIFT

```
Anne Zepecki(Manager)
Lama Abdullah Rashed(Tester)
Jose Antonio Ramos(Language Guru)
Rishav Kumar (System Architect)
Suryanarayana Venkata Akella (System Architect)
```

## INTRODUCTION

Sift is a programming language designed to optimize text processing and filtering for natural language processing (NLP) applications. Sift draws inspiration from the elegance of C’s syntax while adding its own unique flair. This imperative language is designed for users with some programming experience as knowledge of C or a similar language will allow users to instantly recognize and understand the basic structure of Sift. However, it is the text-specific processing tools that make Sift stand out as the best language to use for NLP purposes; piping, filtering, and basic tokenization functionality give users the tools they need to seamlessly integrate Sift into their existing or future NLP workflows.

## LANGUAGE TUTORIAL

## ARCHITECTURAL DIAGRAM

### SCANNER

Filename: scanner.mll

The scanner file takes a Sift source program and translates the stream of characters to a stream of tokens for identifiers, keywords, operators, literals, etc. At this stage, any whitespace and comments are discarded from the stream of tokens.
The scanner is implemented in Ocamllex, and uses regular expressions for scanning string literals, identifiers, digits, and other language constructs. If a token is not identified by the scanner, it will throw an error. The tokens processed by the scanner, are then passed to the parser in the pipeline.

Implemented by: Rishav, José, Lama, Anne, Surya 

### PARSER AND AST

Filename: parser.mly and ast.ml

Parser accepts token generated by the scanner and creates an abstract syntax tree(AST) with the grammar provided in parser.mly. The parser contains a Context Free Grammar(CFG) consisting of productions and their precedence. The parser also defines the entry point of the program. The parser is written in Ocamlyacc. If the syntax of the program is incorrect, then the parser throws a Stdlib.parse_error.

The AST defines token systax tree, having binary and unary operators, primitive data types, expression, and constructs of the language.

Implemented by: José, Lama, Rishav, Anne, Surya 

### SEMANTICS

Filename: sast.ml and semantics.ml

The semantic checker converts the AST into a semantically checked syntax tree(SAST). The semantic analysis performs validations like the variables are declared and have been the correct datatype values. It also maintains the scope of the variables and functions using symbol table(Sift is a statically type language). The SAST also validates whether the in-built C functions have been provided the correct types or not. Once the semantic checks are completed, an SAST is generated which is then given as an input to the IR Generator.

Implemented by: José and Lama

### IR GENERATION

The IR generator takes an SAST and build an LLVM code. We use ocam llvm's library to map expression to LLVM accepted data types. 

Implemented by José, Lama, and Rishav

### BUILT-IN LIBRARIES

Implemented by: Rishav and Surya

## TEST PLAN

Implemented by: Rishav, Lama, Anne and Surya
## SUMMARY
